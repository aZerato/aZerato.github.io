<div data-model="publication_date">12-07-2016</div>

<img data-img="https://cdn.meme.am/instances/69129463.jpg" />
	
<div data-lang="fr">
	<div data-model="title">C# : Vieux projets ADO .NET et LINQ (LINQ TO SQL)</div>
	<div data-model="summary">
		<p>
			Je sors du développement d'une application où j'ai pu plonger dans un code utilisant des librairies récentes. Mais voilà toutes les bonnes choses ont une
			fin ...
		</p>
		<p>
			Adieu les patterns Repository/SelectBuilder/Specifications/ ... On est sur du EntityObject avec des ObjectQuery ☺
			<a href="https://msdn.microsoft.com/fr-fr/library/ff477605(v=vs.100).aspx" target="_blank">Bienvenue sur ADO.NET</a>.
		</p>
	</div>
	<div data-model="content">
		<p>
			Je sors du développement d'une application où j'ai pu plonger dans un code utilisant des librairies récentes. Mais voilà toutes les bonnes choses ont une
			fin ...
		</p>
		<p>
			Adieu les patterns Repository/SelectBuilder/Specifications/ ... On est sur du EntityObject avec des ObjectQuery ☺
			<a href="https://msdn.microsoft.com/fr-fr/library/ff477605(v=vs.100).aspx" target="_blank">Bienvenue sur ADO.NET</a>.
		</p>
		<p>
			L'architecture de la solution est assez bien découpée, et donc nous pouvons retrouver notre "MyAppDBContext".
			Nous avons une méthode "GetList&lt;T&gt;' qui ressemble à ça :
			<prism-component class="language-csharp line-numbers">
			
class MyAppDBContext : ContainerContext
{
	[...]

	public Context Current {
		...
	}

	public IList&lt;T&gt; GetList&lt;T&gt;()
	{
		var type = typeof(T);
		var typeName = type.Name;
		var setName = typeName.EndsWith("y")
			? string.Concat(typeName.Substring(0, typeName.Length - 1), "ies")
			: string.Concat(typeName, "s");
		
		var request = string.replace("SELECT * FROM {0}", setName);

		var result = MyAppDBContext.Current.Execute(request);

		return result.toList();
	}

	[...]
}
			
			</prism-component>
			Et le "ContainerContext" qui est la classe autogénérée qui regroupe nos différents "ObjectQuery" :
			<prism-component class="language-csharp line-numbers">
			
class ContainerContext : ObjectContext
{
	[...]

	/// <summary>
	/// There are no comments for PostLikes in the schema.
	/// </summary>
	[global::System.CodeDom.Compiler.GeneratedCode("System.Data.Entity.Design.EntityClassGenerator", "4.0.0.0")]
	public global::System.Data.Objects.ObjectQuery&lt;PostLike&gt; PostLikes
	{
		get
		{
			if ((this._PostLikes == null))
			{
				this._PostLikes = base.CreateQuery&lt;PostLike&gt;("[PostLikes]");
			}
			return this._PostLikes;
		}
	}
	[global::System.CodeDom.Compiler.GeneratedCode("System.Data.Entity.Design.EntityClassGenerator", "4.0.0.0")]
	private global::System.Data.Objects.ObjectQuery&lt;PostLike&gt; _PostLikes;

	[...]
}
			
			</prism-component>
		</p>
		<p>
			Donc avec cet exemple on peut voir que l'existant n'était pas "performant" et ni évolutif car :
			<ul>
				<li>- On retourne une liste de toutes les colonnes ("SELECT *") alors que je voudrais peut être limité les colonnes à recevoir.</li>
				<li>- On fait un toList() mais si on veut faire des traitements on refiltre la liste.</li>
			</ul>
			Les performances pour une page qui doit afficher une liste d'utilisateurs qui avaient "aimé" un post, donc nous avions un EntityObject "PostLike" qui a un
			"PostLikes ObjectQuery&lt;PostLike&gt;", on attendait 4-5 secondes pour 150-200 enregistrements à parcourir. Car on faisait un truc (moche) pour 
            récupérer tous les ID des utilisateurs : "GetList&lt;PostLike&gt;().Where(f => f.PostID == postID).Select(s => s.UserID);"
		</p>
		<p>
			Bon il faut améliorer ça ! il faut au moins faire notre "Where" avant le "toList()". J'ai regardé en faisant le where via une simple "string" en paramètre
			d'une méthode GetList&lt;T&gt;(string mywhere)' mais à l'utilisation c'est (méga) risquée. 
			Il faut se dire que l'on a LINQ et qu'il faut jouer avec des IQueryable ou des IEnumerable pour pas que 
			notre requete soit interprétée. J'ai cherché et j'ai vu que nos ObjectQuery ont la méthode "asQueryable" !
		</p>

		<h2>Récupérer mes "ObjectQuery" pour un objet T</h2>
		
		<p>
			Bon j'ai une méthode GetList avec un EntityObject T, cet objet T est en relation avec un ObjectQuery (qui a le même nom au pluriel).
			Nous n'avons pas de moyen de récupérer à la volé l'ObjectQuery en rapport à un EntityObject.
		</p>
		<p>
			Les ObjectQuery sont des propriétés de notre "MyAppDBContext", l'idéal serait de se baser sur ces propriétés pour récupérer le bon ObjectQuery, <b>ce n'est pas jolie</b>
			mais via cette méthode on peut récupérer pour une Class la valeurs des objet pour un type d'attribut donné.
			<prism-component class="language-csharp line-numbers">
/// <summary>
/// Query contexts.
/// </summary>
private IDictionary&lt;string, ObjectQuery&gt; queryContexts = new Dictionary&lt;string, ObjectQuery&gt;();

/// <summary>
/// Find for a T object the ObjectQuery concerned.
/// </summary>
/// <typeparam name="T"></typeparam>
/// <returns></returns>
private ObjectQuery FindObjectQuery&lt;T&gt;()
{
	var type = typeof(T);
	var typeName = type.Name;
	var setName = typeName.EndsWith("y")
		? string.Concat(typeName.Substring(0, typeName.Length - 1), "ies")
		: string.Concat(typeName, "s");

	if (this.queryContexts.Count == 0)
	{
		PropertyInfo[] props = typeof(MyAppDBContext).GetProperties();
		foreach (var prop in props)
		{
			if (prop.DeclaringType.BaseType == typeof(ObjectContext))
			{
				var value = prop.GetValue(MyAppDBContext.Current, null);
				this.queryContexts.Add(prop.Name, (ObjectQuery)value);
			}
		}
	}

	ObjectQuery query = null;
	var state = this.queryContexts.TryGetValue(setName, out query);
	if (!state)
	{
		this.queryContexts.TryGetValue(typeName, out query);
	}

	return query;
}		
			</prism-component>
			Par cette méthode je récupère pour toutes les propriétés les objets de ma class MyAppDBContext qui sont de type ObjectQuery 
            et je récupère la valeur de l'objet pour cette propriété (pour mon exemple je récupére toutes les propriétés mais on pourrait en récupérer qu'une seule).
		</p>

		<h2>Passer un ObjectQuery à un Queryable (LINQ to SQL)</h2>
		
		<p>
			Maintenant que nous avons la posibilité de récuperer un ObjectQuery pour un EntityObjet T, il faut pouvoir utiliser
			les méthodes LINQ :
			<prism-component class="language-csharp line-numbers">
/// <summary>
/// Return list.
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="predicate"></param>
/// <returns></returns>
public List&lt;T&gt; GetList&lt;T&gt;(Expression&lt;Func&lt;T, bool&gt;&gt; predicate)
{
	var provider = this.GetQueryable&lt;T&gt;(predicate);

	return provider.ToList();
}

/// <summary>
/// Return IQueryable.
/// Never propose this Queryable object to sub layer !.
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="predicate"></param>
/// <returns></returns>
private IQueryable&lt;T&gt; GetQueryable&lt;T&gt;(Expression&lt;Func&lt;T, bool&gt;&gt; predicate)
{
	var queryContext = this.FindObjectQuery&lt;T&gt;();

	var provider = ((IQueryable&lt;T&gt;)queryContext.AsQueryable()).Where(predicate);

	return provider;
}
			</prism-component>
			Je cast mon ObjectQuery en "Queryable" en plus du "AsQueryable" et j'en profite pour passer mon predicat dans mon Where.
			Je passe par deux méthodes, une méthode pour retourner une IQueryable, que j'ai en privée, et après la méthode public qui retourne la List<T>.
		</p>

		<h2>On améliore encore avec les "SelectBuilder"</h2>
		
		<p>
            Un SelectBuilder est une lambda expression permetant de limiter "le nombre de colonnes" que l'on va récuperer d'un enregistrement (c'est ce que l'expression que l'on met dans notre .Select() de LINQ).
			<prism-component class="language-csharp line-numbers">
/// <summary>
/// Return list.
/// </summary>
/// <typeparam name="T">Object that you want to use to interrogate the linked ObjectQuery.</typeparam>
/// <typeparam name="TResult">Type object that you want to return thanks to the selectbuilder.</typeparam>
/// <param name="predicate"></param>
/// <param name="builder">Select builder.</param>
/// <returns></returns>
public List&lt;TResult&gt; GetList&lt;T, TResult&gt;(Expression&lt;Func&lt;T, bool&gt;&gt; predicate, Expression&lt;Func&lt;T, TResult&gt;&gt; builder)
{
	var provider = this.GetQueryable&lt;T&gt;(predicate).Select(builder);

	return provider.ToList();
}
			</prism-component> 
		</p>

		<h2>Final</h2>

		<p>
			Je passe de ça : "GetList&lt;PostLike&gt;().Where(f => f.PostID == postID).Select(s => s.UserID);" à ça : 
			<prism-component class="language-csharp line-numbers">
class MyView 
{		
	public void Render()
	{
		List&lt;long&gt; userIDs = MyAppDBContext
			.GetList&lt;PostLike, long&gt;(
				f => f.PostID == postID, 
				MyView.SelectUserIDsBuilder());
	}

	public static Expression&lt;Func&lt;PostLike, long&gt;&gt; SelectUserIDsBuilder()
	{
		return postlike => postlike.userID;	
	}
}				
			</prism-component>
			Et niveau temps de traitement on passe de 4-5 sec à 450ms.
		</p>

		<h2>En plus</h2>

		<p>
			On devait récupérer le nombre d'éléments pour un certain objet "Page". Donc dans l'idée était de créer une méthode Count&lt;T&gt; avec T notre objet.
			Mais ceci est possible si notre GetQueryable ne tente pas seulement de récupérer les ObjectQuery.
		</p>
		<p>
			L'objet "Page"" hérité de notre objet "Post".
			Dans le "ContainerContext" notre héritage ce présenté de la sorte :
			<prism-component class="language-csharp line-numbers">
			
class ContainerContext : ObjectContext
{
	[...]

	[global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="MyAppModel", Name="Page")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class Page : Post
    {
		[...]
	}

	[...]
}
			
			</prism-component>
			Pour pouvoir réaliser notre Count voici ce qu'il faut faire :
			<prism-component class="language-csharp line-numbers">
public int CountPages(Expression&lt;Func&lt;Page, bool&gt;&gt; predicate)
{
	return MyAppDBContext.Current.Posts.OfType&lt;Page&gt;().Count(predicate);
}
			</prism-component>
		</p>
	</div>
</div>

<div data-lang="en">
	<div data-model="title">C# : ADO .NET && LINQ (LINQ TO SQL)</div>
	<div data-model="summary">
		Not already translated.
	</div>
	</div>
	<div data-model="content">
		Not already translated.
	</div>
</div>